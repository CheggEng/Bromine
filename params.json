{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","tagline":"JS library for UI testing in the browser","body":"Bromine\r\n=======\r\nBromine is a tool for running UI tests in the browser. It provides a simple-to-use flow control mechanism, as well as utilities for executing DOM events.\r\n\r\n*Bromine was designed to be event based by nature, and relies heavily on [Events.js](https://github.com/arieh/Events), its syntax and its methods for passing event arguments*\r\n##Usage\r\n\r\nFirst - code example:\r\n\r\n\r\n```javascript\r\n    var tester = new Bromine.Tester();\r\n\r\n    var test = tester.registerTest({\r\n        init : function(){\r\n            this.handle = document.querySelector('handle');\r\n            this.target = document.querySelecrot('target');\r\n        },\r\n        destroy : function(){\r\n            this.handle = null;    \r\n        },\r\n        tests : [\r\n            function(){\r\n                //in this example, the click will trigger a transition, so we have\r\n                //to wait until it's done\r\n                Bromine.fireEventWithDelay(this.handle, 'click', this.next);    \r\n            },\r\n            function(){\r\n                if (target.classList.contains('hidden')){\r\n                    this.fail('Target is not visible');    \r\n                }else{\r\n                    this.done();    \r\n                }\r\n            }\r\n        ],\r\n        //first method to register events\r\n        onStart : function(){\r\n            console.log('starting test suite');    \r\n        }\r\n    });\r\n\r\n    //second method of registering events\r\n    test.addEvent('fail', function(e){\r\n        console.log('fail');    \r\n    });\r\n\r\n    tester.run();\r\n```\r\n\r\n###Explanation\r\n\r\nBromine is composed of 3 basic components:\r\n\r\n1. `Bromine.Test` - A test suit, which manages a stack of steps to execute\r\n2. `Bromine.Tester` - A test runner\r\n3. `Bromine.Reporter` - A simple Reporter object for you to extend\r\n4. Event dispatching utilities, such as `Bromine.fireEvent` and `Bromine.fireEventWithDelay`.\r\n\r\nIn the example above, we start by creating a Test-runner. We then register a Test suit on top of it. \r\nInside the test suite, we use `fireEventWithDelay` to execute a 'click' event, and wait before executing the next function in the stack (default is 500ms). The wait is becuase many times we want to wait for a transition or an effect to finish running.\r\n\r\n## Bromine.Test\r\nThe main method for creating Test suites is by using Bromine.Tester#registerTest. \r\nPossible parameters for the Test constructor are:\r\n\r\n* `init` :  a function to run when the test is created\r\n* `destroy` : a function to run when the test is done\r\n* `description` : some textual description of the test\r\n* `depend` : a test name that if fails, will prevent this suit from running\r\n* `tests` : the actual test stack for this suit\r\n* `fail\\_timeout` : how long to wait before reporting a fail (default is 10s). If 0, will not set timeout.\r\n\r\nIn addition, each test fires the following events:\r\n* start : will fire just before the test suit starts running\r\n* done  : will fire when test suit finishes successfuly. \r\n* fail  : will fire when test suit fails\r\n\r\nEach function in the test stack has the following methods at it's disposal:\r\n* `log(obj)` - logs a result into the results stack\r\n* `done` - finished the test successfully\r\n* `fail(msg)` - fails the test\r\n\r\nIn addition, each function has access to 3 methods to contol the flow of the test - `prev`, `current`, and `next`. These can be called and passed around.\r\n\r\n##Bromine.Tester\r\nThe test runner is used to register suites, manage their dependencies, and execute them. It has the following methods:\r\n\r\n* `registerTest(name, options)`\r\n* `registerReporter(reporter)`\r\n* `run()`\r\n* `reset()`\r\n\r\nAnd the following events:\r\n\r\n* testStart\r\n* testDone\r\n* testFail\r\n* done\r\n\r\nThe first 3 pass as arguments the test name and the test instance:\r\n \r\n```javascript\r\n    tester.addEvent('testDone', function(e){\r\n        console.log('test ' + e.name +'passed', e.test.results);   \r\n    });\r\n```\r\n\r\n##Bromine.Reporter\r\nThe framework supplies a simple reporter for you to use. The reporter can either be extended, or you can override it's callbacks.\r\n\r\nUsage:\r\n\r\n```javascript\r\n    var reporter = new Bromine.Reporter;\r\n\r\n    reporter.testStart = function(name, test){};\r\n    reporter.testDone  = function(name, results, test){};\r\n    reporter.testFail  = function(name, results, test){};\r\n    reporter.done = function(results){};\r\n\r\n    tester.registerReporter(reporter);\r\n```\r\n\r\n##Event Dispatching\r\nRight now Bromine supplies 2 simple methods for dispatching events on elements:\r\n\r\n1. `Bromine.fireEvent(element, type)` - will fire a DOM eveny of `type` on `element`\r\n2. `Bromine.fireEventWithDelay(element, type, callback [,delay])` - will fire a DOM event of `type` on `element`, then wait `delay`ms (default is 500) before dispatching `callback`. This is useful when you need to wait for a transition or effect to end before next step.\r\n\r\n### Complex DOM Events\r\nIn case you need special event details (such as clientX or e.keyCode), Bromine supplies 2 helper methods:\r\n\r\n#### Bromine.fireMouseEvent(element, type, params)\r\n\r\nParameters can be:\r\nx, y, details, button, ctrl, alt, shift, meta, relatedTarget   \r\n\r\n#### Bromine.fireKeyboardEvent(element, type, params)\r\n\r\nParameters can be:\r\nctrl, alt, shift, meta, key, charCode\r\n\r\n*Note - these methods are not tested on IE, so I cannot gaurentee they will work on IE < 9 (IE9+ will work fine)*\r\n","name":"Bromine"}